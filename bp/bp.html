
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
"http://www.w3.org/TR/REC-html40/transitional.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>How to use Beautiful Soup</title>
<link rev="made" href="mailto:leonardr@segfault.org">
<link rel="stylesheet" type="text/css" href="soup.css">
<meta name="generator" content="Markov Approximation 1.4 (module: leonardr)">
<meta name="author" content="Leonard Richardson">
</head>
<body bgcolor="white" text="black" link="blue" vlink="660066" alink="red">
<div id="container">
<div id="left">

<style>
 kbd { background: #DDFFDD }
 samp { background: #FFFFDD }
 .comment { background: #FFAAAA }
</style>

<p><b>NOTE:</b> This is an archival document describing the
now-obsolete 2.x version of Beautiful Soup. For the latest version,
see <a href="http://www.crummy.com/software/BeautifulSoup/">the
Beautiful Soup homepage</a>.

<h1>How to Use Beautiful Soup</h1>

<p>This document explains the use of Beautiful Soup: how to create a
parse tree, how to navigate it, and how to search it.

<h2>Quick Start</h2>

<p>Here's a Python session that demonstrates the basic features of Beautiful Soup.

<pre>
&gt;&gt;&gt; from BeautifulSoup import BeautifulSoup
&gt;&gt;&gt; import re
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="comment">#Create the soup</span>
... input = '''&lt;html&gt;
... &lt;head&gt;&lt;title&gt;Page title&lt;/title&gt;&lt;/head&gt;
... &lt;body&gt;
... &lt;p id="firstpara" align="center"&gt;This is paragraph &lt;b&gt;one&lt;/b&gt;.
... &lt;p id="secondpara" align="blah"&gt;This is paragraph &lt;b&gt;two&lt;/b&gt;.
... &lt;/html&gt;'''
&gt;&gt;&gt; <kbd>soup = BeautifulSoup(input)</kbd>
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="comment">#Search the soup</span>
... <kbd>titleTag = soup.html.head.title</kbd>
&gt;&gt;&gt; <kbd class="command">print titleTag</kbd>
<samp>&lt;title&gt;Page title&lt;/title&gt;</samp>
&gt;&gt;&gt;
&gt;&gt;&gt; <kbd>print titleTag.string</kbd>
<samp>Page title</samp>
&gt;&gt;&gt;
&gt;&gt;&gt; <kbd>print len(soup('p'))</kbd>
<samp>2</samp>
&gt;&gt;&gt;
&gt;&gt;&gt; <kbd>print soup('p', {'align' : 'center'})</kbd>
<samp>[&lt;p id="firstpara" align="center"&gt;This is paragraph &lt;b&gt;one&lt;/b&gt;.
&lt;/p&gt;]</samp>
&gt;&gt;&gt;
&gt;&gt;&gt; <kbd>print soup('p', {'align' : 'center'})[0]['id']</kbd>
<samp>firstpara</samp>
&gt;&gt;&gt;
&gt;&gt;&gt; <kbd>print soup.first('p', {'align' : re.compile('^b.*')})['id']</kbd>
<samp>secondpara</samp>
&gt;&gt;&gt;
&gt;&gt;&gt; <kbd>print soup.first('p').b.string</kbd>
<samp>one</samp>
&gt;&gt;&gt;
&gt;&gt;&gt; <kbd>print soup('p')[1].b.string</kbd>
<samp>two</samp>
&gt;&gt;&gt;
&gt;&gt;&gt; <span class="comment">#Modify the soup</span>
... <kbd>titleTag['id']='theTitle'</kbd>
&gt;&gt;&gt; <kbd>titleTag.contents = ['New title.']</kbd>
&gt;&gt;&gt; <kbd>print soup.html.head.title</kbd>
<samp>&lt;title id="theTitle"&gt;New title.&lt;/title&gt;</samp>
</pre>

<h2>Creating and Feeding the Parser</h2>

<p>For most tasks your best bet is the <code>BeautifulSoup</code>
parser. (See the section below, <a href="#ChoosingAParser">"Choosing a
Parser"</a> for situations when you might use the others). You can
construct any of the parsers with no arguments, or you can pass in the
text you want to parse.

<p>If you don't pass in the text you want to parse to the parser
constructor, you'll need to feed text into the parser afterwards,
using the <code>feed()</code> method. Calling <code>feed()</code> more
than once is the same as concatenating a lot of strings together and
calling <code>feed()</code> once. 

<h3>The <code>done()</code> method</h3>

<p>Once you're done feeding text into the parser, call the
<code>done()</code> method so that the parser knows to close any
unclosed tags. If you pass in text to the parser constructor, you
don't need to call <code>done()</code>; it'll happen
automatically. This means that if you pass in text to the parser
constructor, and <i>then</i> call <code>feed()</code>, you might not
get the results you expect: there's a <code>done()</code> call in
between.

<h2>Navigating the Parse Tree</h2>

<p>When you feed a markup document into one of Beautiful Soup's parser
classes, Beautiful Soup transforms the markup into a parse tree: a set
of linked objects representing the structure of the document.

<p>The parser object is the root of the parse tree. Below it are Tag
objects and NavigableText objects. A Tag represents an SGML tag, as
well as anything and everything encountered between that tag and its
closing. A NavigableText object represents a chunk of
ASCII or Unicode text. You can treat it just like a string, but it
also has the navigation members so you can get to other parts of the
parse tree from it.

<p>For concreteness, here's a visual representation of the parse tree
for the example HTML I introduced in the "Quick Start" section. I got
this representation by calling <code>soup.prettify()</code>, and I'll
use it throughout this section to illustrate the navigation. In this
representation, a Tag that's underneath another tag in the parse tree
is displayed with another level of indentation than its parent.

<pre>
 &lt;html&gt;
  &lt;head&gt;
   &lt;title&gt;Page title
   &lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
   &lt;p id="firstpara" align="center"&gt;This is paragraph
    &lt;b&gt;one
    &lt;/b&gt;.
   &lt;/p&gt;
   &lt;p id="secondpara" align="blah"&gt;This is paragraph
    &lt;b&gt;two
    &lt;/b&gt;.
   &lt;/p&gt;
  &lt;/body&gt;
 &lt;/html&gt;
</pre>

<p>This is saying: we've got an <code>html</code> Tag which contains a
<code>head</code> Tag and a <code>body</code> Tag. The
<code>head</code> tag contains a <code>title</code> Tag, which
contains a NavigableText object that says "Page title". The
<code>body</code> Tag contains two <code>p</code> Tags, and so on. I
got this diagram by running the HTML into a <code>BeautifulSoup</code>
parser object and calling <code>prettify()</code> on it.

<p>All Tag objects have all of the members listed below (though the
actual value of the member may be <code>Null</code>). NavigableText
objects have all of them except for <code>contents</code> and
<code>string</code>.

<h3><code>parent</code></h3>

<p>In the example above, the <code>parent</code> of the "head" Tag is
the "html" Tag. The <code>parent</code> of the "html" Tag is the
BeautifulSoup parser object itself. The parent of the parser object is
<code>Null</code>. By following <code>parent</code> you can move up
the parse tree.

<h3><code>contents</code></h3>

<p>With <code>parent</code> you move up the parse tree; With
<code>contents</code> you move down it. This is a list of Tag and
NavigableText objects contained within a tag. Only the top-level
parser object and Tag objects have <code>contents</code>;
NavigableText objects don't have 'em.

<p>In the example above, the <code>contents</code> of the first "p"
Tag is a list containing a NavigableText ("This is paragraph"), a "b"
Tag, and another NavigableText ("."). The <code>contents</code> of the
"b" Tag is a list containing a NavigableText ("one").

<h3><code>string</code></h3>

<p>For your convenience, if a tag has only one child node, and that
child node is an ASCII or Unicode string, the child node is made
available as <code>tag.string</code> as well as
<code>tag.contents[0]</code>. In the example above,
<code>soup.b.string</code> is a NavigableText representing the string
"one". That's the string contained in the first "b" Tag in the parse
tree. <code>soup.p.string</code> is <code>Null</code>, because the
first "p" Tag in the parse tree has more than one
child. <code>soup.head.string</code> is also <code>Null</code>, even
though the "head" Tag has only one child, because that child is a Tag
(the "title" Tag), not a string.

<h3><code>nextSibling</code> and <code>previousSibling</code></h3>

<p>These members let you skip to the next or previous thing on the
same level of the parse tree. For instance, the
<code>nextSibling</code> of the "head" Tag is the "body" Tag, because
the "body" Tag is the next thing directly beneath the "html" Tag. The
<code>nextSibling</code> of the "body" tag is <code>Null</code>,
because there's nothing else directly beneath the "html" Tag.

<p>Conversely, the <code>previousSibling</code> of the "body" Tag is
the "head" tag, and the <code>previousSibling</code> of the "head" Tag
is <code>Null</code>.

<p>Some more examples: the <code>nextSibling</code> of the first "p"
Tag is the second "p" Tag. The <code>previousSibling</code> of the "b"
Tag inside the second "p" Tag is the NavigableText "This is
paragraph". The <code>previousSibling</code> of that NavigableText is
<code>Null</code>, not anything inside the first "p" Tag.

<h3><code>next</code> and <code>previous</code></h3>

<p>These members let you move through the document elements in the
order they were processed by the parser, rather than in the order they
appear in the tree. For instance, the <code>next</code> of the "head"
Tag is the "title" Tag, not the "body" Tag. This is because the
"title" Tag comes immediately after the "head" tag in the original
document. 

<p>Where <code>next</code> and <code>previous</code> are concerned, a
Tag's <code>contents</code> come before whatever is its
<code>nextSibling</code>. You usually won't have to use these members,
but sometimes it's the easiest way to get to something buried inside
the parse tree.

<h3>Iterating over a Tag</h3>

<p>You can iterate over the contents of a tag by treating the Tag
itself as a list. <code>for i in soup.body:</code> is the same as
<code>for i in soup.body.contents:</code>. Both will iterate over
the direct children of the first 'body' Tag found in the parse
tree. Similarly, to see how many child nodes a Tag has, you can call
<code>len(tag)</code> instead of <code>len(tag.contents)</code>.

<h3>Navigate the parse tree by specifying tag names</h3>

<p>It's easy to navigate the parse tree by referencing the name of the
tag you want as a member of the parser or a Tag object. We've been
doing it throughout these examples. In general, calling
<code>tag.foo</code> returns the first child of that tag (direct or
recursive) that happens to be a "foo" Tag. If there aren't any "foo"
Tags beneath a tag, its <code>.foo</code> member is <code>Null</code>.

<p>You can use this to traverse the parse tree, writing code like
<code>soup.html.head.title</code> to get the title of an HTML
document.

<p>You can also use this to quickly jump to a certain part of a parse
tree. For instance, if you're not worried about "title" Tags in weird
places outside of the "head" Tag, you can just use
<code>soup.title</code> to get an HTML document's
title. <code>soup.p</code> jumps to the first "p" Tag inside a
document, wherever it is. <code>soup.table.tr.td</code> jumps
to the first column of the first row of the first table in the
document.

<p>These members actually alias to the <code>first()</code> method,
which is covered below in the section "Searching the Parse Tree". I
mention it here because the alias makes it very easy to zoom in on an
interesting part of a well-known parse tree.

<h4><code>soup.foo</code> versus <code>soup.fooTag</code></h3>

<p>An alternate form of this idiom lets you access the first 'foo' Tag
as <code>.fooTag</code> instead of <code>.foo</code>. For instance,
<code>soup.table.tr.td</code> could also be expressed as
<code>soup.tableTag.trTag.tdTag</code>, or even
<code>soup.tableTag.tr.tdTag</code>. This is useful if you like to be
more explicit about what you're doing, or if you're parsing XML whose
tags contain names that conflict with Beautiful Soup methods and
members.

<p>Suppose you were parsing XML that contained tags called "parent" or
"contents". <code>soup.parent</code> won't trigger this idiom; it
tries to find the parent of the parser object (which is
<code>Null</code>). You can't use that idiom to find the first
"parent" tag in the parse tree.  Instead, use
<code>soup.parentTag</code>.

<h3>The attributes of Tags</h3>

<p>SGML tags have attributes, and so do the Tag objects created by the
parser. For instance, each of the "p" Tags in the example above has an
"id" attribute and an "align" attribute. You can access a Tag's
attributes by treating the Tag as though it were a
dictionary. <code>soup.p['id']</code> retrieves the "id" attribute
of the first "p" Tag. NavigableText objects don't have attributes,
only Tag objects.

<h3>The <code>Null</code> object</h3>

<p>When navigating or searching the parse tree, you may encounter the
<code>Null</code> object. <code>Null</code> is just like Python's
<code>None</code>, but it's easier to work with:

<ul>
<li><code>Null.memberVariable</code> is <code>Null</code>.</li>
<li><code>Null.memberVariable.otherMemberVariable</code> is also <code>Null</code>.</li>
<li><code>Null().methodCall("arg1", "arg2")[0]['key']</code> is,
you guessed it, <code>Null</code>.</li>
</ul>

<p>Try doing any of that with <code>None</code> and you'd get an
exception.

<p>Why is this useful? Consider a line of Beautiful Soup code like
<code>soup.head.title</code>. If Beautiful Soup used <code>None</code>
instead of <code>Null</code>, that code would only work so long all
your documents had a &lt;head&gt; tag containing a &lt;title&gt;
tag. This is not a good assumption to make when you're dealing with
real-world HTML.

<p>For an ill-formed document, <code>soup.html</code> might return
<code>None</code>, and then accessing the <code>title</code> member of
<code>None</code> would throw an
<code>AttributeException</code>. You'd need to check for
<code>None</code> between getting the &lt;head&gt; and getting the
&lt;title&gt;. But since Beautiful Soup actually returns
<code>Null</code> if you ask for something that doesn't exist, and
since you can access <code>Null.title</code> and get another
<code>Null</code>, that code will work no matter what. You'll only
have to check for <code>Null</code> once, at the end.

<h2>Searching the Parse Tree</h2>

<p>Beautiful Soup provides a number of methods for finding
<code>Tag</code>s and text that match criteria you specify. These
methods are available only to <code>Tag</code> objects and to the
top-level parser objects, not to <code>NavigableText</code>
objects. The methods in the next section are also available to
<code>NavigableText</code> objects.

<h3>fetch(name, attrs, recursive, limit)</h3>

<p>The <code>fetch()</code> method traverses the tree and finds all
the tags that match the criteria you gave it.

<p>Calling <code>fetch()</code> on the parser object searches the
entire parse tree. Calling <code>fetch()</code> on a Tag object
searches only the contents of that Tag.

<p><code>fetch()</code> takes four arguments:

<ul>

<li><code>name</code> describes to <code>fetch()</code> which tags the
tags you want to retrieve. <code>name</code> can be any one of the
following:

<ol>
<li>A string. This will match only Tags with that specific name.

<p>For instance, if you wanted to get all of the "a" tags, you could
call <code>soup.fetch('a')</code>.

<li>A list. This will match only Tags whose names are in the list. 

<p>For instance, if you wanted to collect both "font" and "span" tags,
you could call <code>soup.fetch(['font', 'div'])</code>

<li>A dictionary where the keys are the names of Tags you want. This is 
just like the list, but faster.

<p>For instance, if you wanted to collect both "font" and "span" tags,
you could call <code>soup.fetch({'font' : None, 'div' : None})</code>

<li>A compiled regular expression. This will match only Tags
whose names match the regular expression.

<p>For instance, if you wanted to get all tags whose names contained
the letter "a", you could call
<code>soup.fetch(re.compile('a'))</code>

<li>A callable object which takes a Tag object and returns a boolean. This
object will be called once for each Tag encountered, and if it returns True
then the tag is considered to match.
<p>For instance, if you wanted to get only tags whose 'id' attributes matched
their names, you could call: <code>fetch(lambda(x):x.name==x['id'])</code>
</ol>

<li><code>attrs</code> is a map of restrictions on attribute values
which are applied in addition to any restriction on
<code>name</code>. The key of a key-value pair in the attribute map
must be a string: the name of a particular attribute. The value of a
key-value pair in the attribute map works like an argument to
<code>name</code>: it can be a string, a list, a map, a regular
expression, or a callable (a callable must take a string, not a Tag as
with <code>name</code>).

<p>For instance, if you wanted to get only "a" Tags that had non-empty
"href" attributes, you would call <code>soup.fetch('a',
{'href':re.compile('.+')})</code>. If you wanted to get all tags that
had an "width" attribute of 100, you would call
<code>soup.fetch(attrs={'width':100})</code>

<li><code>recursive</code> controls whether to search all the children
of your starting <code>Tag</code>, or whether to search only the
direct children of your starting Tag. By default, searches are
recursive.

<li><code>limit</code> lets you stop the search when a certain number
of results have been found. If there are a thousand tables in your
page, but you only need the fourth one, pass in 4 to
<code>limit</code> and you'll save time. By default, there is no
limit.

</ul>

<p>If you call a Tag object as though it were a function, you're
actually calling that Tag's <code>fetch()</code>
method. <code>tag('tag1', {'attr1':'val1'})</code> is the same as
<code>tag.fetch('tag1', {'attr1':'val1'})</code>, and it's a little
more concise.

<h4><code>attrs</code> convenience alias</h4>

<p>When scraping HTML, the most common use of <code>attrs</code> is to
find tags with a particular CSS class. If you pass in a string (or a
list, or a regular expression, or a callable) instead of a map to
<code>attrs</code>, <code>fetch</code> will assume you want to match
the "class" attribute. Therefore, <code>soup.fetch('foo',
'bar')</code> is the same as <code>soup.fetch('foo', {'class' :
'bar'})</code>. Using this alias can make your code look neater.

<h3>first(name, attrs, recursive)</h3>

<p>The <code>first()</code> method traverses the tree and returns the
first Tag that matches.

<p>The arguments to <code>first()</code> are the same as to
<code>fetch()</code>. It's basically a wrapper to
<code>fetch()</code>, which returns either the first match or
<code>Null</code> if there are no matches.

<p>As with <code>fetch</code>, calling <code>first()</code> on the
parser object searches the entire parse tree. Calling
<code>first()</code> on a Tag object searches only the contents of
that Tag.

<p>As mentioned earlier, accessing the <code>foo</code> or
<code>fooTag</code> member of the parser or a Tag object returns the
first "foo" Tag in the parse tree. It's the same as calling
<code>first("foo")</code>.

<h3>fetchText(text, recursive, limit)</h3>

<p>This is like <code>fetch()</code> for finding text strings
(NavigableText objects) instead of Tag objects. The <code>text</code>
argument is like the <code>name</code> argument of
<code>fetch()</code>. As with <code>name</code>, you can pass in any
of five objects: 

<ul>
<li>A string you want to find.
<li>A list of strings you want to find.
<li>A dictionary where the keys are the strings you want to find. This
is just like the list, but faster.
<li>A regular expression that matches the strings you want to find.
<li>A callable object that takes a string as input and returns whether or
not you want to match that string.
</ul>

<p>The <code>recursive</code> and <code>limit</code> arguments works
just like in <code>fetch()</code>.

<h3>firstText(text, recursive)</h3>

<p>As <code>first()</code> is to <code>fetch()</code>, so is
<code>firstText()</code> to <code>fetchText()</code>. It calls
<code>fetchText()</code> and returns the first item in the list, or
<code>Null</code> if there were no matches.

<h2>Searching Inside the Parse Tree</h2>

<p>You can do most Beautiful Soup operations with the four methods in
the previous section. However, sometimes you can't use them to get
directly to the <code>Tag</code> or <code>NavigableText</code> you
want. For example, consider some HTML like this:

<pre>
from BeautifulSoup import BeautifulSoup
soup = BeautifulSoup('''&lt;ul&gt;
 &lt;li&gt;An unrelated list
&lt;/ul&gt;

&lt;h1&gt;Heading&lt;/h1&gt;
&lt;p&gt;This is &lt;b&gt;the list you want&lt;/b&gt;:&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;The data you want
&lt;/ul&gt;''')
</pre>

<p>There are a number of ways to navigate to that li tag that contains
the data you want. The most obvious is this:

<pre>
soup('li', limit=2)[1]
</pre>

<p>It should be equally obvious that that's not a very stable way to
get that li tag. If you're only scraping this page once it doesn't
matter, but if you're going to scrape it many times over a long
period, such considerations become important. If the irrelevant list
grows another li tag, you'll get that tag instead of the one you want,
and your script will break or give the wrong data.

<pre>
soup('ul', limit=2)[1].li
</pre>

<p>This is a little better, in that it can survive changes to the
irrelevant list, but if the document grows another irrelevant list at
the top, you'll get the first li tag of that list instead of the one
you want. A more reliable way of referring to the ul tag you want
would better reflect that tag's place in the structure of the
document.

<p>When you look at that HTML, you think of the list you want as
'the ul tag beneath the h1 tag'. The problem is that the tag isn't
<i>contained</i> inside the h1 tag; it just comes after it. It's easy
enough to get the h1 tag, but there's no way to get to the ul tag from
there using <code>first()</code> and <code>fetch()</code>. You need to
navigate to it with the <code>next</code> or <code>nextSibling</code>
members:

<pre>
s = soup.h1
while getattr(s, 'name', None) != 'ul':
    s = s.nextSibling
li = s.li
</pre>

<p>Or, if you think this might be more stable:

<pre>
s = soup.firstText('Heading')
while getattr(s, 'name', None) != 'ul':
    s = s.next
li = s.li
</pre>

<p>Both of those examples are more trouble than you should need to go
through, so the methods in this section provide a useful
shorthand. These methods can be used whenever you find yourself
wanting to write a while loop over one of the navigation
members. Given a starting point somewhere in the tree, they navigate
the tree in some way and keep track of <code>Tag</code> or
<code>NavigableText</code> objects that match the criteria you
specify. Instead of the loops in the example code above, you can just
write this:

<pre>
soup.h1.findNextSibling('ul').li
</pre>

<p>Or this:

<pre>
soup.firstText('Heading').findNext('ul').li
</pre>

<p>All of these methods take the same arguments as <code>first</code>
or <code>fetch</code>: an optional way of matching a tag name, an
optional way of matching tag attributes, and an optional way of
matching text.

<p>There are two methods for each navigation member. The methods whose
names look like <code>fetchFoos</code> take an optional limit, like
<code>fetch</code>, and return a list of matches. The methods whose
names look like <code>findFoo</code> are convenience methods which
will stop searching the tree after encountering a match, and will
return that match as a scalar.

<p>These methods are available on the tree as a whole, and also on
<code>Tag</code> and <code>NavigableText</code>
objects. <code>first</code> and <code>fetch</code>, the methods
covered in the previous section, are not available for
<code>NavigableText</code> objects, because those methods search
through a <code>Tag</code>'s children, and <code>NavigableText</code>
objects can't have any children.

<h3><code>findNextSibling(name, attrs, text)</code> and <code>fetchNextSiblings(name, attrs, text, limit)</code></h3>

<p>These methods repeatedly follow an object's
<code>nextSibling</code> member, gathering <code>Tag</code> or
<code>NavigableText</code> objects that match the criteria you specify.

<h3><code>findPreviousSibling(name, attrs, text)</code> and <code>fetchPreviousSiblings(name, attrs, text, limit)</code></h3>

<p>These methods repeatedly follow an object's
<code>previousSibling</code> member, gathering <code>Tag</code> or
<code>NavigableText</code> objects that match the criteria you specify.

<h3><code>findNext(name, attrs, text)</code> and
<code>fetchNext(name, attrs, text, limit)</code></h3>

<p>These methods repeatedly follow an object's <code>next</code>
member, gathering <code>Tag</code> or <code>NavigableText</code>
objects that match the criteria you specify.

<h3><code>findPrevious(name, attrs, text)</code> and
<code>fetchPrevious(name, attrs, text, limit)</code></h3>

<p>These methods repeatedly follow an object's <code>previous</code>
member, gathering <code>Tag</code> or <code>NavigableText</code>
objects that match the criteria you specify.

<h3><code>findParent(name, attrs)</code> and <code>fetchParents(name, attrs, limit)</code></h3>

<p>These methods repeatedly follow an object's <code>parent</code>
member, gathering <code>Tag</code> objects that match the criteria you
specify. Since a <code>NavigableText</code> can have no children,
you'll never get a <code>NavigableText</code> object while calling
<code>findParent</code> or <code>fetchParents</code>. That's why
these methods don't take a <code>text</code> argument.

<a name="PrintingOutTheParseTree"><h2>Printing out the parse tree</h2></a>

<p>If you need to make changes to the parse tree and print it back
out, or just look at how Beautiful Soup decided to parse some bad
HTML, you have a couple options for turning the parse tree back into a
string.

<h3><code>str()</code> and <code>unicode()</code></h3>

<p>The parser objects, as well as each Tag and NavigableText object,
can be printed out as strings. This string will have no unneccessary
whitespace, and all tags will either be self-closing or have
corresponding closing tags in what Beautiful Soup guesses is the right
place. One useful thing you can do with this is clean up HTML into
something approaching XHTML.

<h3><code>prettify()</code></h3>

<p>The <code>prettify()</code> method turns the parse tree (or a
portion of it) into a pretty-printed string. This is just like the
regular string you'd get with <code>print soup</code>, except it uses
whitespace to show the structure of the parse tree. Every tag will
start a new line, and a tag's children will be indented one more level
than its parent.

<p>Remember from earlier examples that Beautiful Soup turned this:

<pre>
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Page title&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;p id="firstpara" align="center"&gt;This is paragraph &lt;b&gt;one&lt;/b&gt;.
&lt;p id="secondpara" align="blah"&gt;This is paragraph &lt;b&gt;two&lt;/b&gt;.
&lt;/html&gt;
</pre>

<p>into this:

<pre>
 &lt;html&gt;
  &lt;head&gt;
   &lt;title&gt;Page title
   &lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
   &lt;p id="firstpara" align="center"&gt;This is paragraph
    &lt;b&gt;one
    &lt;/b&gt;.
   &lt;/p&gt;
   &lt;p id="secondpara" align="blah"&gt;This is paragraph
    &lt;b&gt;two
    &lt;/b&gt;.
   &lt;/p&gt;
  &lt;/body&gt;
 &lt;/html&gt;
</pre>


<a name="ChoosingAParser"><h2>Choosing a parser</h2></a>

<p>Beautiful Soup provides four classes that implement different
parsing strategies. You'll need to choose the right one depending on
your task. For most tasks you'll be able to use
<code>BeautifulSoup</code>, but sometimes one of the other classes
might make things easier for you.

<h3><code>BeautifulSoup</code></h3>

The most popular Beautiful Soup class, this class parses HTML as seen
in the real world. It contains heuristics about common HTML usage and
mis-usage.

<table border="1">
<tr><th>Raw</th><th>Parsed with <code>BeautifulSoup</code></th>
<tr><td valign="top"><pre>
&lt;i&gt;This &lt;span title="a"&gt;is&lt;br&gt; some &lt;html&gt;invalid&lt;/htl %&gt; HTML. 
&lt;sarcasm&gt;It's so great!&lt;/sarcasm&gt;</td>
<td>
<pre> &lt;i&gt;This 
  &lt;span title="a"&gt;is
   &lt;br /&gt; some 
   &lt;html&gt;invalid HTML. 
    &lt;sarcasm&gt;It's so great!
    &lt;/sarcasm&gt;
   &lt;/html&gt;
  &lt;/span&gt;
 &lt;/i&gt;
</pre></td></tr></table>


<h3><code>BeautifulStoneSoup</code></h3>

<p>This class parses any XML-like language. It contains no special
language- or schema-specific heuristics. If you want to define a set
of self-closing tags for your XML schema, you'll need to subclass this
class.

<table border="1">
<tr><th>Raw</th><th>Parsed with <code>BeautifulStoneSoup</code></th>
<tr><td valign="top">
<pre>
&lt;foo key1="value1"&gt;This is some &lt;bar&gt;invalid&lt;/baz&gt; XML.
</pre>
</td><td valign="top">
<pre> &lt;foo key1="value1"&gt;This is some 
  &lt;bar&gt;invalid XML.
  &lt;/bar&gt;
 &lt;/foo&gt;
</td></tr></table>

<h3><code>ICantBelieveItsBeautifulSoup</code></h3>

This is a subclass of <code>BeautifulSoup</code> with different
heuristics.  It's geared towards dealing with bizarre but valid HTML,
like HTML that contains nested inline tags that don't do anything when
you nest them:

<table border="1">
<tr><th>Raw</th><th>Parsed with <code>BeautifulSoup</code></th>
<th>Parsed with <code>ICantBelieveItsBeautifulSoup</code></th>
<tr><td valign="top">
<pre>&lt;b&gt;This text is &lt;b&gt;bolded 
twice&lt;/b&gt; for some reason.
</pre>
</td><td valign="top">
<pre> &lt;b&gt;This text is 
 &lt;/b&gt;
 &lt;b&gt;bolded twice
 &lt;/b&gt; for some reason.</pre>
</td><td valign="top">
<pre> &lt;b&gt;This text is 
  &lt;b&gt;bolded twice
  &lt;/b&gt; for some reason.
 &lt;/b&gt;</pre>
</td></tr></table>

<h3><code>BeautifulSOAP</code></h3>

<p>This is a convenience subclass of <code>BeautifulStoneSoup</code>
which makes it easier to deal with XML documents (like SOAP messages)
that put data in tiny sub-elements when it would be more convenient to
put them in attributes of the parent element.

<table border="1">
<tr>
<th>Raw</th><th>Parsed with <code>BeautifulSOAP</code></th></tr>
<tr><td valign="top">
<pre>&lt;foo&gt;&lt;bar&gt;baz&lt;/bar&gt;&lt;/foo&gt;</pre>
</td><td valign="top">
<pre> &lt;foo bar="baz"&gt;
  &lt;bar&gt;baz
  &lt;/bar&gt;
 &lt;/foo&gt;</pre>
</td></tr></table>

<h2>Advanced Topics: Building a custom parser</h2>
 
<p>As befits an "advanced topics" section, I haven't written this yet.

<h3>Sanitizing Bad Data with Regexes</h3>

<p>...</p>

<h3>Customizing the Tag Maps</h3>

<p>...</p>
</div>

<div id="right">
<img src="6.1.jpg" height="250"><br />
<blockquote class="alice">
The Fish-Footman began by... saying, in a
solemn tone, "For the Duchess. An invitation from the Queen to play
croquet." The Frog-Footman repeated, in the same solemn tone, only
changing the order of the words a little, "From the Queen. An
invitation for the Duchess to play croquet."

<p>Then they both bowed low, and their curls got entangled together. 
</blockquote>

<hr>
<ul>
<li><a href="index.html">Homepage</a>
<li><a href="index.html#Download">Download</a>
<li><a href="CHANGELOG.html">What's new</a>
<li><a href="documentation.html">Documentation</a>
<li><a href="examples.html">Examples</a>
<li><a href="FAQ.html">FAQ</a>
<li><a href="TODO.html">To-do list</a>
<li><a href="AUTHORS.html">Contributors</a>
</ul>

</div>
<div>&nbsp;</div><div align="center"><script type="text/javascript"><!--
        google_ad_client = "pub-8573159021431108";
        google_ad_width = 728;
        google_ad_height = 90;
        google_ad_format = "728x90_as";
        google_ad_type = "text";
        google_ad_channel ="";
        google_color_border = "CCCCCC";
        google_color_bg = "FFFFFF";
        google_color_link = "000000";
        google_color_url = "666666";
        google_color_text = "333333";
        //--></script>
        <script type="text/javascript"
        src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
        </script></div><hr><table><tr><td valign="top">
<p>This document (<a href="/source/software/BeautifulSoup/documentation.bhtml">source</a>) is part of Crummy, the webspace of <a href="/self/">Leonard Richardson</a> (<a href="/self/contact.html">contact information</a>). It was last modified on Wednesday, May 04 2005, 19:17:58 Nowhere Daylight Time and last built on Sunday, May 28 2006, 09:00:58 Nowhere Daylight Time.</p><p><table class="licenseText"><tr><td><a href="http://creativecommons.org/licenses/by-sa/2.0/"><img border="0" src="/nb//resources/img/somerights20.jpg"></a></td><td valign="top">Crummy is &copy; 1996-2006 Leonard Richardson. Unless otherwise noted, all text licensed under a <a href="http://creativecommons.org/licenses/by-sa/2.0/">Creative Commons License</a>.</td></tr></table></span><!--<rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><Work rdf:about="http://www.crummy.com/"><dc:title>Crummy: The Site</dc:title><dc:rights><Agent><dc:title>Crummy: the Site</dc:title></Agent></dc:rights><dc:format>text/html</dc:format><license rdf:resource=http://creativecommons.org/licenses/by-sa/2.0//></Work><License rdf:about="http://creativecommons.org/licenses/by-sa/2.0/"></License></rdf:RDF>--></p></td><td valign=top><p><b>Document tree:</b>
<dl><dd><a href="http://www.crummy.com/">http://www.crummy.com/</a><dl><dd><a href="http://www.crummy.com/software/">software/</a><dl><dd><a href="http://www.crummy.com/software/BeautifulSoup/">BeautifulSoup/</a><dl><dd><a href="http://www.crummy.com/software/BeautifulSoup/documentation.html">documentation.html</a></dl>
</dl>
</dl>
</dl>


Site Search:

<form method="get" action="/search/">
        <input type="text" name="q" maxlength="255" value=""></input>
        </form>
        </td>

</tr>
</div>
</table>
</body>
</html>

